import shutil
import subprocess
import argparse
from typing import List
import yaml
from pathlib import Path
import pygmentation.pygmentation as pyg
import datetime
import re


base_dir = Path(".").resolve()


crossref_metadata = """# pandoc-crossref configs
figPrefix:
  - "figure"
  - "figures"
tblPrefix:
  - "table"
  - "tables"
eqnPrefix:
  - "equation"
  - "equations"
eqnPrefixTemplate: '$$p$$&nbsp;($$i$$)'
equationNumberTeX: '\\tag'
eqnIndexTemplate: '$$i$$'

linkReferences: true

subfigureChildTemplate: '<span class="subfigure-name">($$i$$)&nbsp;</span> &nbsp;$$t$$'
subfigureTemplate: '<span class="figure-name">$$figureTitle$$ $$i$$$$titleDelim$$</span> $$t$$'
figureTemplate: '<span class="figure-name">$$figureTitle$$ $$i$$$$titleDelim$$</span> $$t$$'"""


replacements = {
    "latex": {
        "all": [
            # Remove extra spaces before punctuation
            (r"(\\\)|\})\s+([\.,\?])", r"\1\2"),
            # Remove extra spaces after an open bracket
            (r"(\(|\{)\s+", r"\1"),
            # remove par breaks at start and end of environments and macros
            (r"\\begin{(.*?)}\s*", r"\\begin{\1}"),
            (r"\s*\\end{(.*?)}", r"\\end{\1}"),
            (r"\{\s+\n\n\s*", r"{ "),
            (r"\{\n\n\s*", r"{"),
            (r"\s*\n\n\s+\}", r" }"),
            (r"\s*\n\n\s*\}", r"}"),
            # Change the odd figure format from pandoc-crossref
            (r"\\begin\{pandoccrossrefsubfigures\}", r"\\begin{figure}[ht!]" + "\n\\\\centering"),
            (r"\\end\{pandoccrossrefsubfigures\}", r"\\end{figure}"),
            # add keepaspectratio to the figures generated by pandoc-crossref
            (r"\\includegraphics\[(.*?)\]\{(.*?)\}", r"\\includegraphics[\1,keepaspectratio]{\2}"),
        ],
        "notes": [
        ],
        "slides": [
            # If an \item is a display equation, remove the bullet point
            (r"\\item\s*(?=(\\begin{equation}|\\\[))", r"\\item[]"),
            # Remove the automatically added frametitles
            (r"\\begin{frame}{(.*?)}", r"\\begin{frame}"),
            # add a \pause to the start of each frame
            (r"\\begin{frame}((\[.\])?)", r"\\begin{frame}\1\n\t\\pause"),
        ]
    },
    "html": {
        "all": [
            # Remove extra spaces before punctuation
            (r"([>\)])\s+(\W)", r"\1\2"),
            # Remove extra spacing around math
            (r"(\W)\s+\\\(", r"\1\\("),
            (r"\\\)\s+(\W)", r"\\)\1"),
            # Remove extra spaces between number and punctuation
            (r"(\d)\s+([\.,\?])", r"\1\2"),
        ],
        "notes": [],
        "slides": [],
        "chunked": []
    }
}

def parse_args():
    # python3 make.py web|pdf [notes|slides|chunked]
    parser = argparse.ArgumentParser(description="Build a lecturemd project")
    parser.add_argument("output", choices=["web", "pdf", "all"], help="Output format.")
    parser.add_argument("format", choices=["notes", "slides", "chunked"], nargs="?", help="Output type. If unspecified, all are built. `chunked` is only available for web output.")
    args = parser.parse_args()
    if args.output == "pdf" and args.format == "chunked":
        parser.error("Chunked output is only available for web output.")
    return args


def read_settings(base_dir: Path) -> dict:
    settings_path = base_dir / ".lecturemd/lecturemd.yaml"
    if not settings_path.exists():
        raise FileNotFoundError("Settings file not found")
    if not settings_path.is_file():
        raise FileNotFoundError("Settings file is not a file")
    with open(settings_path, "r") as f:
        settings = yaml.safe_load(f)
    if settings["general"]["date"] == "today":
        settings["general"]["date"] = datetime.date.today().isoformat()
    return settings


def create_build_dir(build_dir: Path) -> None:
    if not build_dir.exists():
        build_dir.mkdir()
        return
    if not build_dir.is_dir():
        raise FileExistsError(f"Build directory \"{build_dir}\" exists but is not a directory")
    

def copy_figures(base_dir: Path, build_dir: Path) -> None:
    figures_dir = base_dir / "figures"
    if not figures_dir.exists():
        return
    if not figures_dir.is_dir():
        raise FileNotFoundError(f"Figures directory \"{figures_dir}\" exists but is not a directory")
    target_figures_dir = build_dir / "figures"
    shutil.copytree(figures_dir, target_figures_dir, dirs_exist_ok=True)


def convert_figures(build_dir: Path, extension: str) -> None:
    # Convert any pdf files in the figures directory to the specified extension
    # if svg, use pdf2svg
    # otherwise, try convert
    if not extension.startswith("."):
        extension = "." + extension
    figures_dir = build_dir / "figures"
    for figure in figures_dir.iterdir():
        if not figure.is_file():
            continue
        if not figure.suffix == ".pdf":
            continue
        if extension == ".svg":
            subprocess.run(["pdf2svg", figure, figure.with_suffix(".svg")])
        else:
            subprocess.run(["convert", "-density", "300", "-quality", "100", figure, figure.with_suffix(extension)])


def copy_logo(build_dir: Path, logo: dict, extension: str) -> dict:
    if logo["main logo"] is None and logo["footer logo"] is None:
        return logo
    if not extension.startswith("."):
        extension = "." + extension
    logo_dir = build_dir/"figures"/"logo"
    if not logo_dir.exists():
        logo_dir.mkdir()
    if not logo_dir.is_dir():
        raise FileExistsError(f"Logo directory \"{logo_dir}\" exists but is not a directory")
    logos = {}
    for logo_type in ["main logo", "footer logo"]:
        logo_file = logo[logo_type]
        if logo_file is None:
            logos[logo_type] = None
            continue
        logo_file = Path(logo_file)
        if not logo_file.exists():
            raise FileNotFoundError(f"Logo file \"{logo_file}\" not found")
        if not logo_file.is_file():
            raise FileNotFoundError(f"Logo file \"{logo_file}\" is not a file")
        # move the file to the logo directory
        new_logo_file = logo_dir/logo_file.name
        shutil.copy(logo_file, new_logo_file)
        logos[logo_type] = {"pdf": logo_dir/new_logo_file.name}
        # if it's a pdf, convert the file to the specified extension
        if logo_file.suffix == ".pdf":
            if extension == ".svg":
                subprocess.run(["pdf2svg", new_logo_file, new_logo_file.with_suffix(".svg")])
                logos[logo_type]["web"] = "figures/logo/" + new_logo_file.with_suffix(".svg").name
            else:
                subprocess.run(["convert", "-density", "300", new_logo_file, "-quality", "100", new_logo_file.with_suffix(extension)])
                logos[logo_type]["web"] = "figures/logo/" + new_logo_file.with_suffix(extension).name
        else:
            logos[logo_type]["web"] = "figures/logo/" + new_logo_file.name
    return logos

def copy_styles(base_dir: Path, styles_dir: Path) -> None:
    if not styles_dir.exists():
        styles_dir.mkdir()
    if not styles_dir.is_dir():
        raise FileExistsError(f"Styles directory \"{styles_dir}\" exists but is not a directory")
    styles_src = base_dir/"styles"
    if not styles_src.exists():
        return
    if not styles_src.is_dir():
        raise FileNotFoundError(f"Styles directory \"{styles_src}\" exists but is not a directory")
    # copy the entire directory
    shutil.copytree(styles_src, styles_dir, dirs_exist_ok=True)


def create_colour_scheme(styles_dir: Path, colour_scheme: str) -> None:
    pyg.set_scheme(colour_scheme)
    scheme = pyg.get_scheme()

    with open(styles_dir/"colour_scheme.css", "w+") as f:
        f.write(scheme.to_css())
    
    with open(styles_dir/"colour_scheme.tex", "w+") as f:
        f.write(scheme.to_latex())
    

def sanitize_filename(filename: str) -> str:
    return "".join([c if c.isalnum() or c in ["_", "-"] else "_" for c in filename])


def resolve_filter_path(file_path: str) -> str:
    filter_dir = Path(__file__).parent/"filters"
    if file_path.startswith("$lecturemd"):
        filter_file = filter_dir/file_path[len("$lecturemd/"):]
        filter_file = filter_file.resolve().absolute()
        if not filter_file.exists():
            raise FileNotFoundError(f"Filter file \"{filter_file}\" not found")
        if not filter_file.is_file():
            raise FileNotFoundError(f"Filter file \"{filter_file}\" is not a file")
        return str(filter_file)
    return file_path


def run_pandoc(input_file: str, defaults_file: Path, use_pyndoc: bool = False) -> None:
    if use_pyndoc:
        result = subprocess.run(["python3", "-m", "pyndoc", "--preprocess", "--defaults", defaults_file, input_file], capture_output=True)
    else:
        result = subprocess.run(["pandoc", "--defaults", defaults_file, input_file], capture_output=True)
    if result.returncode != 0:
        print(result.stderr.decode("utf-8"))
        raise ValueError("Pandoc failed to run")


def run_latexmk(tex_file: Path) -> None:
    result = subprocess.run(["latexmk", "-pdf", "-cd", "-f", "-interaction=nonstopmode", tex_file], capture_output=True)
    if result.returncode != 0:
        print(result.stderr.decode("utf-8"))
        raise ValueError("Latexmk failed to run")
    # use latexmk -c to clean up
    subprocess.run(["latexmk", "-c", "-cd", tex_file])
    # remove the tex file
    tex_file.unlink()


def gather_filters(filters_list: List) -> List:
    filters = []
    for filter in filters_list:
        if isinstance(filter, dict):
            if len(filter) != 1:
                raise ValueError("Invalid filter dictionary")
            for key, value in filter.items():
                filters.append((key, value))
        else:
            filters.append((filter, 0))

    # sort the filters by priority
    filters.sort(key=lambda x: x[1])
    return [resolve_filter_path(f[0]) for f in filters]


def build_pdf_notes(base_dir: Path, build_dir: Path, settings: dict, logos: dict) -> None:
    if settings["general"]["subtitle"] is not None:
        tex_file = build_dir/(sanitize_filename(settings["general"]["subtitle"]) + "_notes.tex")
    elif settings["general"]["title"] is not None:
        tex_file = build_dir/(sanitize_filename(settings["general"]["title"]) + "_notes.tex")
    else:
        tex_file = build_dir/"latex_notes.tex"
    pandoc_settings = {
        "writer": "latex",
        "standalone": True,
        "template": str(base_dir/".lecturemd/templates/latex_notes.tex"),
        "output-file": str(tex_file),
        "columns": 1000,
        "default-image-extension": settings["latex"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        }
    }

    header_includes = []
    header_includes.extend([str(base_dir/fname) for fname in settings["latex"]["preamble"]])
    header_includes.extend([str(base_dir/fname) for fname in settings["latex"]["notes"]["preamble"]])
    header_includes.extend([str(base_dir/fname) for fname in settings["general"]["maths preamble"]])

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["pdf"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["pdf"])

    pandoc_settings["filters"] = gather_filters(settings["general"]["filters"] + settings["latex"]["filters"] + settings["latex"]["notes"]["filters"])

    crossref_file = base_dir/".lecturemd"/"defaults"/"crossref.yaml"
    with open(crossref_file, "w+") as f:
        f.write(crossref_metadata)

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    defaults_file = base_dir/".lecturemd"/"defaults"/"pdf_notes.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(settings["general"]["main file"], defaults_file, settings["general"]["use pyndoc"])

    with open(tex_file, "r") as f:
        content = f.read()
    
    for replacement in replacements["latex"]["all"]:
        content = re.sub(replacement[0], replacement[1], content)
    
    for replacement in replacements["latex"]["notes"]:
        content = re.sub(replacement[0], replacement[1], content)

    with open(tex_file, "w+") as f:
        f.write(content)

    run_latexmk(tex_file)


def build_pdf_slides(base_dir: Path, build_dir: Path, settings: dict, logos: dict) -> None:
    if settings["general"]["subtitle"] is not None:
        tex_file = build_dir/(sanitize_filename(settings["general"]["subtitle"]) + "_slides.tex")
    elif settings["general"]["title"] is not None:
        tex_file = build_dir/(sanitize_filename(settings["general"]["title"]) + "_slides.tex")
    else:
        tex_file = build_dir/"latex_slides.tex"
    pandoc_settings = {
        "writer": "beamer",
        "standalone": True,
        "template": str(base_dir/".lecturemd/templates/latex_slides.tex"),
        "output-file": str(tex_file),
        "columns": 1000,
        "default-image-extension": settings["latex"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
        "slide-level": 4,
        "incremental": True,
    }

    crossref_file = base_dir/".lecturemd"/"defaults"/"crossref.yaml"
    with open(crossref_file, "w+") as f:
        f.write(crossref_metadata)

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    header_includes = []
    header_includes.extend([str(base_dir/fname) for fname in settings["latex"]["preamble"]])
    header_includes.extend([str(base_dir/fname) for fname in settings["latex"]["slides"]["preamble"]])
    header_includes.extend([str(base_dir/fname) for fname in settings["general"]["maths preamble"]])

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["pdf"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["pdf"])

    pandoc_settings["filters"] = gather_filters(settings["general"]["filters"] + settings["latex"]["filters"] + settings["latex"]["slides"]["filters"])

    defaults_file = base_dir/".lecturemd"/"defaults"/"pdf_slides.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(settings["general"]["main file"], defaults_file, settings["general"]["use pyndoc"])

    with open(tex_file, "r") as f:
        content = f.read()
    
    for replacement in replacements["latex"]["all"]:
        content = re.sub(replacement[0], replacement[1], content)
    
    for replacement in replacements["latex"]["slides"]:
        content = re.sub(replacement[0], replacement[1], content)
    
    with open(tex_file, "w+") as f:
        f.write(content)

    run_latexmk(tex_file)

    # remove .nav and .snm files
    for file in build_dir.glob("*.nav"):
        file.unlink()
    for file in build_dir.glob("*.snm"):
        file.unlink()

def build_web_notes(base_dir: Path, build_dir: Path, settings: dict, logos: dict) -> None:
    if settings["general"]["subtitle"] is not None:
        html_file = build_dir/(sanitize_filename(settings["general"]["subtitle"]) + "_notes.html")
    elif settings["general"]["title"] is not None:
        html_file = build_dir/(sanitize_filename(settings["general"]["title"]) + "_notes.html")
    else:
        html_file = build_dir/"html_notes.html"

    pandoc_settings = {
        "writer": "html",
        "standalone": True,
        "template": str(base_dir/".lecturemd/templates/html_notes.html"),
        "html-math-method": {
            "method": "mathjax",
        },
        "output-file": str(html_file),
        "columns": 1000,
        "default-image-extension": settings["html"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
        "toc": True,
        "toc-depth": 4,
        "css": settings["html"]["styles"] + settings["html"]["notes"]["styles"],
    }

    crossref_file = base_dir/".lecturemd"/"defaults"/"crossref.yaml"
    with open(crossref_file, "w+") as f:
        f.write(crossref_metadata)

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    header_includes = []
    header_includes.extend([str(base_dir/fname) for fname in settings["html"]["preamble"]])
    header_includes.extend([str(base_dir/fname) for fname in settings["html"]["notes"]["preamble"]])
    to_remove = []
    for fname in settings["general"]["maths preamble"]:
        # this is a .tex file, we need to create a .html file with the same name and content, but encased in \(...\) for mathjax
        with open(base_dir/fname, "r") as f:
            content = f.read()
        html_fname = build_dir/(Path(fname).stem + ".html")
        with open(html_fname, "w+") as f:
            f.write("\\(" + content + "\\)")
        header_includes.append(str(html_fname))
        to_remove.append(html_fname)

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["web"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["web"])

    pandoc_settings["filters"] = gather_filters(settings["general"]["filters"] + settings["html"]["filters"] + settings["html"]["notes"]["filters"])

    defaults_file = base_dir/".lecturemd"/"defaults"/"web_notes.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(settings["general"]["main file"], defaults_file, settings["general"]["use pyndoc"])

    for file in to_remove:
        file.unlink()

    with open(html_file, "r") as f:
        content = f.read()

    for replacement in replacements["html"]["all"]:
        content = re.sub(replacement[0], replacement[1], content)
    
    for replacement in replacements["html"]["notes"]:
        content = re.sub(replacement[0], replacement[1], content)

    with open(html_file, "w+") as f:
        f.write(content)


def build_web_slides(base_dir: Path, build_dir: Path, settings: dict, logos: dict) -> None:
    if settings["general"]["subtitle"] is not None:
        html_file = build_dir/(sanitize_filename(settings["general"]["subtitle"]) + "_slides.html")
    elif settings["general"]["title"] is not None:
        html_file = build_dir/(sanitize_filename(settings["general"]["title"]) + "_slides.html")
    else:
        html_file = build_dir/"web_slides.html"

    pandoc_settings = {
        "writer": "revealjs",
        "standalone": True,
        "template": str(base_dir/".lecturemd/templates/html_slides.html"),
        "html-math-method": {
            "method": "mathjax",
        },
        "output-file": str(html_file),
        "columns": 1000,
        "default-image-extension": settings["html"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
            "disableLayout": False,
            "width": 1080,
        },
        "slide-level": 3,
        "incremental": True,
        "css": settings["html"]["styles"] + settings["html"]["slides"]["styles"],
    }

    crossref_file = base_dir/".lecturemd"/"defaults"/"crossref.yaml"
    with open(crossref_file, "w+") as f:
        f.write(crossref_metadata)

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    header_includes = []
    header_includes.extend([str(base_dir/fname) for fname in settings["html"]["preamble"]])
    header_includes.extend([str(base_dir/fname) for fname in settings["html"]["slides"]["preamble"]])
    to_remove = []
    for fname in settings["general"]["maths preamble"]:
        # this is a .tex file, we need to create a .html file with the same name and content, but encased in \(...\) for mathjax
        with open(base_dir/fname, "r") as f:
            content = f.read()
        html_fname = build_dir/(Path(fname).stem + ".html")
        with open(html_fname, "w+") as f:
            f.write("\\(" + content + "\\)")
        header_includes.append(str(html_fname))
        to_remove.append(html_fname)
    
    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["web"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["web"])
    
    pandoc_settings["filters"] = gather_filters(settings["general"]["filters"] + settings["html"]["filters"] + settings["html"]["slides"]["filters"])

    defaults_file = base_dir/".lecturemd"/"defaults"/"web_slides.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(settings["general"]["main file"], defaults_file, settings["general"]["use pyndoc"])

    for file in to_remove:
        file.unlink()

    with open(html_file, "r") as f:
        content = f.read()
    
    for replacement in replacements["html"]["all"]:
        content = re.sub(replacement[0], replacement[1], content)
    
    for replacement in replacements["html"]["slides"]:
        content = re.sub(replacement[0], replacement[1], content)
    
    with open(html_file, "w+") as f:
        f.write(content)

def build_web_chunked(base_dir: Path, build_dir: Path, settings: dict, logos: dict) -> None:
    if settings["general"]["subtitle"] is not None:
        html_file = build_dir/(sanitize_filename(settings["general"]["subtitle"]) + "_chunked")
    elif settings["general"]["title"] is not None:
        html_file = build_dir/(sanitize_filename(settings["general"]["title"]) + "_chunked")
    else:
        html_file = build_dir/"web_chunked"
    
    # if the directory already exists, pandoc will throw an error. We need to remove it (recursively)
    if html_file.exists():
        if html_file.is_dir():
            shutil.rmtree(html_file)
        else:
            html_file.unlink()

    pandoc_settings = {
        "writer": "chunkedhtml",
        "standalone": True,
        "template": str(base_dir/".lecturemd/templates/html_chunked.html"),
        "html-math-method": {
            "method": "mathjax",
        },
        "output-file": str(html_file),
        "columns": 1000,
        "default-image-extension": settings["html"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
        "split-level": 3,
        "toc": True,
        "css": settings["html"]["styles"] + settings["html"]["notes"]["styles"],
    }

    crossref_file = base_dir/".lecturemd"/"defaults"/"crossref.yaml"
    with open(crossref_file, "w+") as f:
        f.write(crossref_metadata)

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    header_includes = []
    header_includes.extend([str(base_dir/fname) for fname in settings["html"]["preamble"]])
    header_includes.extend([str(base_dir/fname) for fname in settings["html"]["notes"]["preamble"]])
    to_remove = []
    for fname in settings["general"]["maths preamble"]:
        # this is a .tex file, we need to create a .html file with the same name and content, but encased in \(...\) for mathjax
        with open(base_dir/fname, "r") as f:
            content = f.read()
        html_fname = build_dir/(Path(fname).stem + ".html")
        with open(html_fname, "w+") as f:
            f.write("\\(" + content + "\\)")
        header_includes.append(str(html_fname))
        to_remove.append(html_fname)

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["web"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["web"])

    pandoc_settings["filters"] = gather_filters(settings["general"]["filters"] + settings["html"]["filters"] + settings["html"]["notes"]["filters"])

    defaults_file = base_dir/".lecturemd"/"defaults"/"web_chunked.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(settings["general"]["main file"], defaults_file, settings["general"]["use pyndoc"])

    # copy the `build/styles` directory into the html_file directory
    shutil.copytree(base_dir/"build"/"styles", html_file/"styles", dirs_exist_ok=True)

    # same with the figures directory
    shutil.copytree(base_dir/"build"/"figures", html_file/"figures", dirs_exist_ok=True)

    for file in to_remove:
        file.unlink()

    files = [f for f in html_file.iterdir() if f.is_file() and f.suffix == ".html"]

    for file in files:
        with open(file, "r") as f:
            content = f.read()
        
        for replacement in replacements["html"]["all"]:
            content = re.sub(replacement[0], replacement[1], content)

        for replacement in replacements["html"]["chunked"]:
            content = re.sub(replacement[0], replacement[1], content)

        with open(file, "w+") as f:
            f.write(content)


def main(
    build_dir: Path,
    output: str,
    format: str | None,
):
    build_dir: Path = base_dir / "build"
    styles_dir = build_dir/"styles"
    settings: dict = read_settings(base_dir)
    create_build_dir(build_dir)
    copy_figures(base_dir, build_dir)
    if output in ["web", "all"]:
        convert_figures(build_dir, settings["html"]["figure extension"])
    logos = copy_logo(build_dir, settings["general"]["logo"], settings["html"]["figure extension"])
    copy_styles(base_dir, styles_dir)
    create_colour_scheme(styles_dir, settings["general"]["colour scheme"])
    if output in ["pdf", "all"]:
        if format is None or format == "notes":
            build_pdf_notes(base_dir, build_dir, settings, logos)
        if format is None or format == "slides":
            build_pdf_slides(base_dir, build_dir, settings, logos)
    if output in ["web", "all"]:
        if format is None or format == "notes":
            build_web_notes(base_dir, build_dir, settings, logos)
        if format is None or format == "slides":
            build_web_slides(base_dir, build_dir, settings, logos)
        if format is None or format == "chunked":
            build_web_chunked(base_dir, build_dir, settings, logos)


if __name__ == "__main__":
    args = parse_args()
    main(args.output, args.format)