import shutil
import subprocess
import argparse
from typing import List
import yaml
from pathlib import Path
import pygmentation.pygmentation as pyg
import datetime
import re

from enum import Enum
import platform
import time

from rich.progress import Progress, TimeElapsedColumn, TextColumn, BarColumn

def format_elapsed_time(t_ns: float):
    # time is in nanoseconds, format in an appropriate unit to 3 significant figures (NOT 3 decimal places)
    timestring = None
    unit = None
    if t_ns < 1e3:
        # return f"{t_ns:#.3g} ns"
        timestring = f"{t_ns:#.3g}"
        unit = "ns"
    elif t_ns < 1e6:
        # return f"{t_ns / 1e3:#.3g} \xb5s"
        timestring = f"{t_ns / 1e3:#.3g}"
        unit = "\xb5s"
    elif t_ns < 1e9:
        # return f"{t_ns / 1e6:#.3g} ms"
        timestring = f"{t_ns / 1e6:#.3g}"
        unit = "ms"
    elif t_ns < 60e9:
        # return f"{t_ns / 1e9:#.3g} s"
        timestring = f"{t_ns / 1e9:#.3g}"
        unit = "s"
    elif t_ns < 60e9 * 60:
        # return as ##m ##s
        m = int(t_ns / 60e9)
        s = int((t_ns - m * 60e9) / 1e9)
        return f"{m}m {s:0>2d}s"
    else:
        # return as ##h ##m ##s. I really hope we never need this
        h = int(t_ns / 3600e9)
        m = int((t_ns - h * 3600e9) / 60e9)
        s = int((t_ns - h * 3600e9 - m * 60e9) / 1e9)
        return f"{h}h {m:0>2d}m {s:0>2d}s"

    if timestring.endswith("."):
        timestring = timestring[:-1]
    return timestring + " " + unit


class Platform(Enum):
    LINUX = 0
    WINDOWS = 1
    MAC = 2
    JAVA = 3
    UNKNOWN = 4


def get_platform() -> Platform:
    system = platform.system()
    if system == "Linux":
        return Platform.LINUX
    elif system == "Windows":
        return Platform.WINDOWS
    elif system == "Darwin":
        return Platform.MAC
    elif system == "Java":
        return Platform.JAVA
    else:
        return Platform.UNKNOWN


operating_system = get_platform()
if operating_system == Platform.UNKNOWN:
    print(
        "Warning: Unsupported or unknown operating system. This can cause unexpected results or unhelpful errors."
    )


def is_installed(program: str) -> bool:
    return shutil.which(program) is not None


base_dir = Path(".").resolve()


crossref_metadata = """# pandoc-crossref configs
figPrefix:
  - "figure"
  - "figures"
tblPrefix:
  - "table"
  - "tables"
eqnPrefix:
  - "equation"
  - "equations"
eqnPrefixTemplate: '$$p$$&nbsp;($$i$$)'
equationNumberTeX: '\\\\tag'
eqnIndexTemplate: '$$i$$'

linkReferences: true

subfigureChildTemplate: '<span class="subfigure-name">($$i$$)&nbsp;</span> &nbsp;$$t$$'
subfigureTemplate: '<span class="figure-name">$$figureTitle$$ $$i$$$$titleDelim$$</span> $$t$$'
figureTemplate: '<span class="figure-name">$$figureTitle$$ $$i$$$$titleDelim$$</span> $$t$$'"""


replacements = {
    "latex": {
        "all": [
            # Remove extra spaces before punctuation
            (r"(\\\)|\})\s+([\.,\?])", r"\1\2"),
            # Remove extra spaces after an open bracket
            (r"(\(|\{)\s+", r"\1"),
            # remove par breaks at start and end of environments and macros
            (r"\\begin{(.*?)}\s*", r"\\begin{\1}"),
            (r"\s*\\end{(.*?)}", r"\\end{\1}"),
            (r"\{\s+\n\n\s*", r"{ "),
            (r"\{\n\n\s*", r"{"),
            (r"\s*\n\n\s+\}", r" }"),
            (r"\s*\n\n\s*\}", r"}"),
            # Change the odd figure format from pandoc-crossref
            (
                r"\\begin\{pandoccrossrefsubfigures\}",
                r"\\begin{figure}[ht!]" + "\n\\\\centering",
            ),
            (r"\\end\{pandoccrossrefsubfigures\}", r"\\end{figure}"),
            # add keepaspectratio to the figures generated by pandoc-crossref
            (
                r"\\includegraphics\[(.*?)\]\{(.*?)\}",
                r"\\includegraphics[\1,keepaspectratio]{\2}",
            ),
        ],
        "notes": [],
        "slides": [
            # If an \item is a display equation, remove the bullet point
            (r"\\item\s*(?=(\\begin{equation}|\{?\\\[))", r"\\item[]"),
            # Remove the automatically added frametitles
            (r"\\begin{frame}((\[.*?\])?){(.*?)}", r"\\begin{frame}\1"),
            # add a \pause to the start of each frame
            (r"\\begin{frame}((\[.*?\])?)", r"\\begin{frame}\1\n\t\\pause"),
            # Remove `fragile` frame options
            (r"\\begin{frame}\[fragile\]", r"\\begin{frame}"),
        ],
    },
    "html": {
        "all": [
            # Remove extra spaces before punctuation
            (r"([>\)])\s+(\W)", r"\1\2"),
            # Remove extra spacing around math
            (r"(\W)\s+\\\(", r"\1\\("),
            (r"\\\)\s+(\W)", r"\\)\1"),
            # Remove extra spaces between number and punctuation
            (r"(\d)\s+([\.,\?])", r"\1\2"),
        ],
        "notes": [],
        "slides": [],
        "chunked": [],
    },
}


def parse_args():
    # python3 make.py web|pdf [notes|slides|chunked]
    parser = argparse.ArgumentParser(description="Build a lecturemd project")
    parser.add_argument("output", choices=["web", "pdf", "all"], help="Output format.")
    parser.add_argument(
        "format",
        choices=["notes", "slides", "chunked"],
        nargs="?",
        help="Output type. If unspecified, all are built. `chunked` is only available for web output.",
    )
    args = parser.parse_args()
    if args.output == "pdf" and args.format == "chunked":
        parser.error("Chunked output is only available for web output.")
    return args


def read_settings(base_dir: Path) -> dict:
    settings_path = base_dir / ".lecturemd/lecturemd.yaml"
    if not settings_path.exists():
        raise FileNotFoundError("Settings file not found")
    if not settings_path.is_file():
        raise FileNotFoundError("Settings file is not a file")
    with open(settings_path, "r") as f:
        settings = yaml.safe_load(f)
    if settings["general"]["date"] == "today":
        settings["general"]["date"] = datetime.date.today().isoformat()
    return settings


def create_build_dir(build_dir: Path) -> None:
    if not build_dir.exists():
        build_dir.mkdir()
        return
    if not build_dir.is_dir():
        raise FileExistsError(
            f'Build directory "{build_dir}" exists but is not a directory'
        )


def copy_figures(base_dir: Path, build_dir: Path) -> None:
    figures_dir = base_dir / "figures"
    if not figures_dir.exists():
        return
    if not figures_dir.is_dir():
        raise FileNotFoundError(
            f'Figures directory "{figures_dir}" exists but is not a directory'
        )
    target_figures_dir = build_dir / "figures"
    shutil.copytree(figures_dir, target_figures_dir, dirs_exist_ok=True)


def convert_file(source: Path, extension: str, dest: Path = None) -> None:
    if not extension.startswith("."):
        extension = "." + extension
    if dest is None:
        dest = source.with_suffix(extension)
    if extension == ".svg":
        if is_installed("pdf2svg"):
            subprocess.run(["pdf2svg", source, dest])
            return dest
        if is_installed("inkscape"):
            subprocess.run(
                ["inkscape", source, "--export-type=svg", "--export-filename=" + dest]
            )
            return dest
        raise FileNotFoundError(
            "Both pdf2svg and inkscape are not installed. Unable to convert file for web output."
        )

    if operating_system in [Platform.LINUX, Platform.MAC]:
        if not is_installed("convert"):
            raise FileNotFoundError(
                "ImageMagick is not installed. Unable to convert file for web output."
            )
        subprocess.run(["convert", "-density", "300", "-quality", "100", source, dest])
        return dest
    if operating_system == Platform.WINDOWS:
        if not is_installed("magick"):
            raise FileNotFoundError(
                "ImageMagick is not installed. Unable to convert file for web output."
            )
        subprocess.run(["magick", "-density", "300", "-quality", "100", source, dest])
        return dest
    raise Exception(
        "Unsupported or unknown operating system. Unable to convert file for web output."
    )


def convert_figures(build_dir: Path, extension: str) -> None:
    # Convert any pdf files in the figures directory to the specified extension
    # if svg, use pdf2svg
    # otherwise, try convert
    if not extension.startswith("."):
        extension = "." + extension
    figures_dir = build_dir / "figures"
    for figure in figures_dir.iterdir():
        if not figure.is_file():
            continue
        if not figure.suffix == ".pdf":
            continue
        convert_file(figure, extension)


def copy_logo(build_dir: Path, logo: dict, extension: str) -> dict:
    if logo["main logo"] is None and logo["footer logo"] is None:
        return logo
    if not extension.startswith("."):
        extension = "." + extension
    logo_dir = build_dir / "figures" / "logo"
    if not logo_dir.exists():
        logo_dir.mkdir()
    if not logo_dir.is_dir():
        raise FileExistsError(
            f'Logo directory "{logo_dir}" exists but is not a directory'
        )
    logos = {}
    for logo_type in ["main logo", "footer logo"]:
        logo_file = logo[logo_type]
        if logo_file is None:
            logos[logo_type] = None
            continue
        logo_file = Path(logo_file)
        if not logo_file.exists():
            raise FileNotFoundError(f'Logo file "{logo_file}" not found')
        if not logo_file.is_file():
            raise FileNotFoundError(f'Logo file "{logo_file}" is not a file')
        # move the file to the logo directory
        new_logo_file = logo_dir / logo_file.name
        shutil.copy(logo_file, new_logo_file)
        logos[logo_type] = {"pdf": logo_dir / new_logo_file.name}
        # if it's a pdf, convert the file to the specified extension
        if logo_file.suffix == ".pdf":
            new_logo_file = convert_file(new_logo_file, extension)
            logos[logo_type]["web"] = "figures/logo/" + new_logo_file.name
        else:
            logos[logo_type]["web"] = "figures/logo/" + new_logo_file.name
    return logos


def copy_styles(base_dir: Path, styles_dir: Path) -> None:
    if not styles_dir.exists():
        styles_dir.mkdir()
    if not styles_dir.is_dir():
        raise FileExistsError(
            f'Styles directory "{styles_dir}" exists but is not a directory'
        )
    styles_src = base_dir / "styles"
    if not styles_src.exists():
        return
    if not styles_src.is_dir():
        raise FileNotFoundError(
            f'Styles directory "{styles_src}" exists but is not a directory'
        )
    # copy the entire directory
    shutil.copytree(styles_src, styles_dir, dirs_exist_ok=True)


def create_colour_scheme(styles_dir: Path, colour_scheme: str) -> None:
    pyg.set_scheme(colour_scheme)
    scheme = pyg.get_scheme()

    with open(styles_dir / "colour_scheme.css", "w+") as f:
        f.write(scheme.to_css())

    with open(styles_dir / "colour_scheme.tex", "w+") as f:
        f.write(scheme.to_latex())


def sanitize_filename(filename: str) -> str:
    return "".join([c if c.isalnum() or c in ["_", "-"] else "_" for c in filename])


def resolve_filter_path(file_path: str) -> str:
    filter_dir = Path(__file__).parent / "filters"
    if file_path.startswith("$lecturemd"):
        filter_file = filter_dir / file_path[len("$lecturemd/") :]
        filter_file = filter_file.resolve().absolute()
        if not filter_file.exists():
            raise FileNotFoundError(f'Filter file "{filter_file}" not found')
        if not filter_file.is_file():
            raise FileNotFoundError(f'Filter file "{filter_file}" is not a file')
        return str(filter_file)
    return file_path


def run_pandoc(input_file: str, defaults_file: Path, use_pyndoc: bool = False) -> None:
    if use_pyndoc:
        result = subprocess.run(
            [
                "python3",
                "-m",
                "pyndoc",
                "--preprocess",
                "--defaults",
                defaults_file,
                input_file,
            ],
            capture_output=True,
        )
    else:
        result = subprocess.run(
            ["pandoc", "--defaults", defaults_file, input_file], capture_output=True
        )
    if result.returncode != 0:
        print(result.stderr.decode("utf-8"))
        raise ValueError("Pandoc failed to run")


def run_latexmk(tex_file: Path) -> None:
    result = subprocess.run(
        ["latexmk", "-pdf", "-cd", "-f", "-interaction=nonstopmode", tex_file],
        capture_output=True,
    )
    if result.returncode != 0:
        print(result.stderr.decode("utf-8"))
        raise ValueError("Latexmk failed to run")
    # use latexmk -c to clean up
    subprocess.run(["latexmk", "-c", "-cd", tex_file], capture_output=True)
    # remove the tex file
    tex_file.unlink()


def gather_filters(filters_list: List) -> List:
    filters = []
    for filter in filters_list:
        if isinstance(filter, dict):
            if len(filter) != 1:
                raise ValueError("Invalid filter dictionary")
            for key, value in filter.items():
                filters.append((key, value))
        else:
            filters.append((filter, 0))

    # sort the filters by priority
    filters.sort(key=lambda x: x[1])
    return [resolve_filter_path(f[0]) for f in filters]


def write_crossref() -> None:
    crossref_file = base_dir / ".lecturemd" / "defaults" / "crossref.yaml"
    if not crossref_file.parent.exists():
        crossref_file.parent.mkdir(parents=True)
    with open(crossref_file, "w+") as f:
        f.write(crossref_metadata)
    return crossref_file


def build_pdf_notes(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict
) -> None:
    if settings["general"]["subtitle"] is not None:
        tex_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_notes.tex"
        )
    elif settings["general"]["title"] is not None:
        tex_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_notes.tex"
        )
    else:
        tex_file = build_dir / "latex_notes.tex"
    pandoc_settings = {
        "writer": "latex",
        "standalone": True,
        "template": str(base_dir / ".lecturemd/templates/latex_notes.tex"),
        "output-file": str(tex_file),
        "columns": 1000,
        "default-image-extension": settings["latex"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
    }

    header_includes = []
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["latex"]["preamble"]]
    )
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["latex"]["notes"]["preamble"]]
    )
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["general"]["maths preamble"]]
    )

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["pdf"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["pdf"])

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["latex"]["filters"]
        + settings["latex"]["notes"]["filters"]
    )

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    defaults_file = base_dir / ".lecturemd" / "defaults" / "pdf_notes.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
    )

    with open(tex_file, "r") as f:
        content = f.read()

    for replacement in replacements["latex"]["all"]:
        content = re.sub(replacement[0], replacement[1], content)

    for replacement in replacements["latex"]["notes"]:
        content = re.sub(replacement[0], replacement[1], content)

    with open(tex_file, "w+") as f:
        f.write(content)

    run_latexmk(tex_file)


def build_pdf_slides(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict
) -> None:
    if settings["general"]["subtitle"] is not None:
        tex_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_slides.tex"
        )
    elif settings["general"]["title"] is not None:
        tex_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_slides.tex"
        )
    else:
        tex_file = build_dir / "latex_slides.tex"
    pandoc_settings = {
        "writer": "beamer",
        "standalone": True,
        "template": str(base_dir / ".lecturemd/templates/latex_slides.tex"),
        "output-file": str(tex_file),
        "columns": 1000,
        "default-image-extension": settings["latex"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
        "slide-level": 4,
        "incremental": True,
    }

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    header_includes = []
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["latex"]["preamble"]]
    )
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["latex"]["slides"]["preamble"]]
    )
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["general"]["maths preamble"]]
    )

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["pdf"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["pdf"])

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["latex"]["filters"]
        + settings["latex"]["slides"]["filters"]
    )

    defaults_file = base_dir / ".lecturemd" / "defaults" / "pdf_slides.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
    )

    with open(tex_file, "r") as f:
        content = f.read()

    for replacement in replacements["latex"]["all"]:
        content = re.sub(replacement[0], replacement[1], content)

    for replacement in replacements["latex"]["slides"]:
        content = re.sub(replacement[0], replacement[1], content)

    with open(tex_file, "w+") as f:
        f.write(content)

    run_latexmk(tex_file)

    # remove .nav, .snm, .vrb files
    for file in build_dir.glob("*.nav"):
        file.unlink()
    for file in build_dir.glob("*.snm"):
        file.unlink()
    for file in build_dir.glob("*.vrb"):
        file.unlink()


def build_web_notes(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict
) -> None:
    if settings["general"]["subtitle"] is not None:
        html_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_notes.html"
        )
    elif settings["general"]["title"] is not None:
        html_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_notes.html"
        )
    else:
        html_file = build_dir / "html_notes.html"

    pandoc_settings = {
        "writer": "html",
        "standalone": True,
        "template": str(base_dir / ".lecturemd/templates/html_notes.html"),
        "html-math-method": {
            "method": "mathjax",
        },
        "output-file": str(html_file),
        "columns": 1000,
        "default-image-extension": settings["html"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
        "toc": True,
        "toc-depth": 4,
        "css": settings["html"]["styles"] + settings["html"]["notes"]["styles"],
    }

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    header_includes = []
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["html"]["preamble"]]
    )
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["html"]["notes"]["preamble"]]
    )
    to_remove = []
    for fname in settings["general"]["maths preamble"]:
        # this is a .tex file, we need to create a .html file with the same name and content, but encased in \(...\) for mathjax
        with open(base_dir / fname, "r") as f:
            content = f.read()
        html_fname = build_dir / (Path(fname).stem + ".html")
        with open(html_fname, "w+") as f:
            f.write("\\(" + content + "\\)")
        header_includes.append(str(html_fname))
        to_remove.append(html_fname)

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["web"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["web"])

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["html"]["filters"]
        + settings["html"]["notes"]["filters"]
    )

    defaults_file = base_dir / ".lecturemd" / "defaults" / "web_notes.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
    )

    for file in to_remove:
        file.unlink()

    with open(html_file, "r") as f:
        content = f.read()

    for replacement in replacements["html"]["all"]:
        content = re.sub(replacement[0], replacement[1], content)

    for replacement in replacements["html"]["notes"]:
        content = re.sub(replacement[0], replacement[1], content)

    with open(html_file, "w+") as f:
        f.write(content)


def build_web_slides(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict
) -> None:
    if settings["general"]["subtitle"] is not None:
        html_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_slides.html"
        )
    elif settings["general"]["title"] is not None:
        html_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_slides.html"
        )
    else:
        html_file = build_dir / "web_slides.html"

    pandoc_settings = {
        "writer": "revealjs",
        "standalone": True,
        "template": str(base_dir / ".lecturemd/templates/html_slides.html"),
        "html-math-method": {
            "method": "mathjax",
        },
        "output-file": str(html_file),
        "columns": 1000,
        "default-image-extension": settings["html"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
            "disableLayout": False,
            "width": 1080,
        },
        "slide-level": 3,
        "incremental": True,
        "css": settings["html"]["styles"] + settings["html"]["slides"]["styles"],
    }

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    header_includes = []
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["html"]["preamble"]]
    )
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["html"]["slides"]["preamble"]]
    )
    to_remove = []
    for fname in settings["general"]["maths preamble"]:
        # this is a .tex file, we need to create a .html file with the same name and content, but encased in \(...\) for mathjax
        with open(base_dir / fname, "r") as f:
            content = f.read()
        html_fname = build_dir / (Path(fname).stem + ".html")
        with open(html_fname, "w+") as f:
            f.write("\\(" + content + "\\)")
        header_includes.append(str(html_fname))
        to_remove.append(html_fname)

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["web"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["web"])

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["html"]["filters"]
        + settings["html"]["slides"]["filters"]
    )

    defaults_file = base_dir / ".lecturemd" / "defaults" / "web_slides.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
    )

    for file in to_remove:
        file.unlink()

    with open(html_file, "r") as f:
        content = f.read()

    for replacement in replacements["html"]["all"]:
        content = re.sub(replacement[0], replacement[1], content)

    for replacement in replacements["html"]["slides"]:
        content = re.sub(replacement[0], replacement[1], content)

    with open(html_file, "w+") as f:
        f.write(content)


def build_web_chunked(
    base_dir: Path, build_dir: Path, settings: dict, logos: dict
) -> None:
    if settings["general"]["subtitle"] is not None:
        html_file = build_dir / (
            sanitize_filename(settings["general"]["subtitle"]) + "_chunked"
        )
    elif settings["general"]["title"] is not None:
        html_file = build_dir / (
            sanitize_filename(settings["general"]["title"]) + "_chunked"
        )
    else:
        html_file = build_dir / "web_chunked"

    # if the directory already exists, pandoc will throw an error. We need to remove it (recursively)
    if html_file.exists():
        if html_file.is_dir():
            shutil.rmtree(html_file)
        else:
            html_file.unlink()

    pandoc_settings = {
        "writer": "chunkedhtml",
        "standalone": True,
        "template": str(base_dir / ".lecturemd/templates/html_chunked.html"),
        "html-math-method": {
            "method": "mathjax",
        },
        "output-file": str(html_file),
        "columns": 1000,
        "default-image-extension": settings["html"]["figure extension"],
        "metadata": {
            "title": settings["general"]["title"],
            "subtitle": settings["general"]["subtitle"],
            "author": settings["general"]["author"],
            "date": settings["general"]["date"],
            "institution": settings["general"]["institution"],
        },
        "resource-path": ["build"],
        "split-level": 3,
        "toc": True,
        "css": settings["html"]["styles"] + settings["html"]["notes"]["styles"],
    }

    crossref_file = write_crossref()

    pandoc_settings["metadata-files"] = [str(crossref_file)]

    header_includes = []
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["html"]["preamble"]]
    )
    header_includes.extend(
        [str(base_dir / fname) for fname in settings["html"]["notes"]["preamble"]]
    )
    to_remove = []
    for fname in settings["general"]["maths preamble"]:
        # this is a .tex file, we need to create a .html file with the same name and content, but encased in \(...\) for mathjax
        with open(base_dir / fname, "r") as f:
            content = f.read()
        html_fname = build_dir / (Path(fname).stem + ".html")
        with open(html_fname, "w+") as f:
            f.write("\\(" + content + "\\)")
        header_includes.append(str(html_fname))
        to_remove.append(html_fname)

    pandoc_settings["include-in-header"] = header_includes

    if not logos["main logo"] is None:
        pandoc_settings["metadata"]["main-logo"] = str(logos["main logo"]["web"])
    if not logos["footer logo"] is None:
        pandoc_settings["metadata"]["footer-logo"] = str(logos["footer logo"]["web"])

    pandoc_settings["filters"] = gather_filters(
        settings["general"]["filters"]
        + settings["html"]["filters"]
        + settings["html"]["notes"]["filters"]
    )

    defaults_file = base_dir / ".lecturemd" / "defaults" / "web_chunked.yaml"
    if not defaults_file.parent.exists():
        defaults_file.parent.mkdir(parents=True)
    with open(defaults_file, "w+") as f:
        yaml.dump(pandoc_settings, f)

    run_pandoc(
        settings["general"]["main file"],
        defaults_file,
        settings["general"]["use pyndoc"],
    )

    # copy the `build/styles` directory into the html_file directory
    shutil.copytree(
        base_dir / "build" / "styles", html_file / "styles", dirs_exist_ok=True
    )

    # # same with the figures logo directory
    logo_source_dir = base_dir / "build" / "figures" / "logo"
    if logo_source_dir.exists():
        shutil.copytree(logo_source_dir, html_file / "figures/logo", dirs_exist_ok=True)

    for file in to_remove:
        file.unlink()

    files = [f for f in html_file.iterdir() if f.is_file() and f.suffix == ".html"]

    for file in files:
        with open(file, "r") as f:
            content = f.read()

        for replacement in replacements["html"]["all"]:
            content = re.sub(replacement[0], replacement[1], content)

        for replacement in replacements["html"]["chunked"]:
            content = re.sub(replacement[0], replacement[1], content)

        with open(file, "w+") as f:
            f.write(content)

def end_progress_task(task: int, progress: Progress):
    progress.start_task(task)
    progress.update(task, total = 1, completed = 1, visible = False)


def main(
    build_dir: Path,
    output: str,
    format: str | None,
):
    build_dir: Path = base_dir / "build"
    styles_dir = build_dir / "styles"
    settings: dict = read_settings(base_dir)
    create_build_dir(build_dir)
    copy_figures(base_dir, build_dir)
    if output in ["web", "all"]:
        convert_figures(build_dir, settings["html"]["figure extension"])
    logos = copy_logo(
        build_dir, settings["general"]["logo"], settings["html"]["figure extension"]
    )
    copy_styles(base_dir, styles_dir)
    create_colour_scheme(styles_dir, settings["general"]["colour scheme"])
    with Progress(
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TimeElapsedColumn(),
    ) as progress:
        if output in ["pdf", "all"]:
            if format is None or format == "notes":
                task = progress.add_task("Building PDF notes", total=None)
                start_time = time.perf_counter_ns()
                build_pdf_notes(base_dir, build_dir, settings, logos)
                end_time = time.perf_counter_ns()
                end_progress_task(task, progress)
                progress.console.print(f"Built PDF notes in {format_elapsed_time(end_time - start_time)}")
            if format is None or format == "slides":
                task = progress.add_task("Building PDF slides", total=None)
                start_time = time.perf_counter_ns()
                build_pdf_slides(base_dir, build_dir, settings, logos)
                end_time = time.perf_counter_ns()
                end_progress_task(task, progress)
                progress.console.print(f"Built PDF slides in {format_elapsed_time(end_time - start_time)}")
        if output in ["web", "all"]:
            if format is None or format == "notes":
                task = progress.add_task("Building web notes", total=None)
                start_time = time.perf_counter_ns()
                build_web_notes(base_dir, build_dir, settings, logos)
                end_time = time.perf_counter_ns()
                end_progress_task(task, progress)
                progress.console.print(f"Built web notes in {format_elapsed_time(end_time - start_time)}")
            if format is None or format == "slides":
                task = progress.add_task("Building web slides", total=None)
                start_time = time.perf_counter_ns()
                build_web_slides(base_dir, build_dir, settings, logos)
                end_time = time.perf_counter_ns()
                end_progress_task(task, progress)
                progress.console.print(f"Built web slides in {format_elapsed_time(end_time - start_time)}")
            if format is None or format == "chunked":
                task = progress.add_task("Building web chunked", total=None)
                start_time = time.perf_counter_ns()
                build_web_chunked(base_dir, build_dir, settings, logos)
                end_time = time.perf_counter_ns()
                end_progress_task(task, progress)
                progress.console.print(f"Built web chunked in {format_elapsed_time(end_time - start_time)}")
    # remove any log files we generated. filter.log, pyndoc.*.log
    for file in base_dir.glob("filter.log"):
        file.unlink()
    for file in base_dir.glob("pyndoc.*.log"):
        file.unlink()

if __name__ == "__main__":
    args = parse_args()
    main(args.output, args.format)
